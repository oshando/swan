<spark.Response: void redirect(java.lang.String,int)> 
<spark.staticfiles.StaticFilesConfiguration: void setExpireTimeSeconds(long)> 
<spark.Service: void webSocket(java.lang.String,java.lang.Object)> 
<spark.utils.StringUtils: java.lang.String replace(java.lang.String,java.lang.String,java.lang.String)> 
<spark.route.SimpleRouteMatcher: void parseValidateAddRoute(java.lang.String,java.lang.String,java.lang.Object)> 
<spark.utils.MimeParse: spark.utils.MimeParse$FitnessAndQuality fitnessAndQualityParsed(java.lang.String,java.util.Collection)> 
<spark.Spark: void setPort(int)> 
<spark.utils.MimeParse: spark.utils.MimeParse$ParseResults parseMediaRange(java.lang.String)> 
<spark.utils.IOUtils: byte[] toByteArray(java.io.InputStream)> 
<spark.serialization.BytesSerializer: void process(java.io.OutputStream,java.lang.Object)> 
<spark.Response: void redirect(java.lang.String)> 
<spark.http.matching.RequestWrapper: void setDelegate(spark.Request)> 
<spark.Spark: void setIpAddress(java.lang.String)> 
<spark.utils.IOUtils: long copyLarge(java.io.Reader,java.io.Writer)> 
<spark.Service: void addWebSocketHandler(java.lang.String,spark.embeddedserver.jetty.websocket.WebSocketHandlerWrapper)> 
<spark.http.matching.ResponseWrapper: void setDelegate(spark.Response)> 
<spark.serialization.DefaultSerializer: void process(java.io.OutputStream,java.lang.Object)> 
<spark.serialization.Serializer: void setNext(spark.serialization.Serializer)> 
<spark.Service: void webSocket(java.lang.String,java.lang.Class)> 
<spark.http.matching.Body: void set(java.lang.Object)> 
<spark.utils.IOUtils: long copyLarge(java.io.InputStream,java.io.OutputStream)> 
<spark.Spark: void setSecure(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> 
